***Contents***:

Relative to the directory in which this file is contained, you may find the following:

 ./data - Contains CSV files generated by the program to generate the graphs to be used in the report.
 ./docs - UML class diagram.
 ./src - Contains all the C++ source code required to perform the experiments.
 ./CMakeLists.txt - Used by CMake to allow cross-platform building of this C++ project.

***Running the program***:

To build this program on eceubuntu, first, within the same folder as this README file,
call "cmake ."; this initializes the CMake configuration. After this is done,
call "cmake --build ." to build the binary.

To run the program after building with CMake, call "./bin/ECE358-L2".

The program will automatically show a list of commands, their usage and description.
Very rigorous error-checking was implemented.

This program was designed to be able to perform multiple simulations and generate
multiple CSV outputs in a single session, also allowing you to change multiple simulation
parameters in one line.

**Running it on Visual Studio Community Edition**:

As if 2020-03-17, we were only able to get our use of C++ templates to build using the
Visual Studio Community Edition's implementation of CMake. One must make a new
CMake project out of the extracted ECE358-L2 directory. At the top ribbon, one must
then click "CMake -> Build All" and then click the "Main.cpp" "run program" button;
you may have to first go to the Solution Explorer, right-click ./src/Main.cpp and
click "Set As Startup Item". A command prompt will be opened and the list of commands
shown.

***The state of this submission***:

When approaching this lab, it was unfortunately determined that there is likely a
potentially major flaw in the default description of the simulation algorithm as
described in the lab manual and slides. As a result, the code likely doesn't build
yet despite being largely fledged out and structured with all of its interfaces,
whereby good and superior data could probably be obtainable if given a few extra hours.

All the code is thoroughly documented with programming comments, whereby given our
time constraints, direct consultation of the code is the best way to ascertain its
structure, design and functionality. The structure of main, and the concept of
"simulators" and "analyzers" is very similar to our Lab 1 submission, so please
consult that lab's report for an idea.

Firstly, from a basic calculation, it was confirmed that "late collisions" shouldn't be
possible in this network given the lab parameters
(see https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection#Late_collision).

The desired exercise was to implement the program in accordance with the SOLID programming principles
in order to generate potentially enterprise quality code (see https://en.wikipedia.org/wiki/SOLID).
It is quite time-consuming to design code to be loosely coupled, but is arguably a valuable practice
for the industry.

The flaw is that the prescribed algorithm may actually _erroneously_ mark the channel at a node's
location as being busy at a certain time; that is, the channel is _not_ always busy for the whole
duration of the original transmitting node's frame transmission. It is possible, especially with a
fast channel propagation speed, after choosing a sending node, for subsequent and sufficiently
temporally and spatially close node to begin transmitting such that the sending node's transmission
time is cut short, _and_ as a result, a third node could have actually started transmitting quite
earlier _without_ a collision or sensing that the channel was busy.

With the prescribed implementation, what happens is that the second node correctly detects a collision,
but the third node erroneously senses the channel as being busy when in reality, it wouldn't have because
the sending node would have stopped transmitting or aborted earlier than its nominal transmission time.

If the sending node and second node's frames are transmitted very close in time and these two nodes
are very close spatially, then the error in the duration of the channel busy time is maximized.

Simply, the prescribed solution isn't sophisticated enough.

Thus, an alternate approach was attempted in which one still has a data structure of nodes with
frame queues that are populated accordingly. To implement the loop for finding the earliest frame
among the nodes, we would have used a priority queue anyways. This priority queue was expanded into
a full fledged generic DiscreteEventSimulator<> implementation and hence a NetworkSimulator class.
The NetworkSimulator class allows for special Network events linked to specific nodes to be registered.

The big idea is that each node stores a counter for determining if the channel is busy at its location.
Each node when transmitting then sends transmission start or stop events to all the other nodes which
will update their busy counters accordingly. This architecture allows for a _much_ more accurate
determination of when a channel is actually busy while additionally facilitating an implementation of the
jamming signal delay.

Please judge whether a slightly late but working submission of this sophisticated implementation
would be acceptable.

***Time Spent***:

~22 hours of pre-deadline work

2020-03-12:

***Main changes***:

- The "CSMACDChannelBusy_Event" classes were changed to be generic and not specific to CSMA/CD.
- The "ChannelSenseEvent" class was renamed to "TransmissionAttemptEvent".
- The proposed "CSMACDTransmissionStopEvent" was changed to a generic "TransmissionStopEvent".
- Implemented the Visitor Pattern where the "Node" class can now accept the above events, or rather
  the state they wish for it to process. The event classes now do not perform any state changes of
  their own, instead delegating it to the specific "Node" class implementation.
- Deprecated and removed the "ChannelSenseEventFactory" and "CSMACDChannelSenseEventFactory" classes.
- Changed network topologies to be defined by the addition of various "ChannelConnection" instances
  to each "Node". Instead of having a dedicated "UniformBus" class, the "UniformBusSimulatorConfigurer"
  will build a bus network accordingly.
- Added a "cancelled" flag to the "DiscreteEvent<>" class to allow events to be ignored instead of
  going through the difficulty of removing them from the priority queue before they have been reached.
- Changed the totalTransmittedBits counter into a double to handle massive values.

***Time Spent***:

~12 hour of post-deadline thought, design and implementation.

2020-03-13:

***Time Spent***:

2.5 hours to fix all compiler and linker errors
6 hours debugging logic errors
1 hour testing and gathering/analyzing data (still in progress)

First test commands:
t 1000 ni 20 a 7 r 1000000 l 1500 d 10 p 2e8 m 0 oc
t 1000 nl 20 nu 100 ns 20 a 7 r 1000000 l 1500 d 10 p 2e8 m 0 oc

2020-03-14:

***Time Spent***:

3 hours making a UML class diagram summarizing the design and class interactions

2020-03-16:

***Time Spent***:

2 hours adding more statistics
1 hour acquiring default data
1 hour adding logic for determining the average number of backoff iterations per initiated backoff
1 hour gathering and analyzing data

2020-03-17:

***Report***:

For the sake of time and given the nature of our data, all report-related explanations will remain in this file.

All testing was performed in Windows using the free Visual Studio Community Edition's implementation of CMake.
There was no time to resolve any Linux-specific build or link errors.

**Explanation of Design**:

Please consult "./docs/Class diagram.png" for a UML class diagram showing the program's structure and key interactions
between the different event types.

As usual, the program was designed as an exercise to adhere to SOLID (https://en.wikipedia.org/wiki/SOLID)
programming principles and loose coupling, with abstract classes defined and specialized derivative classes
implemented.

Again, the I/O and error-checking logic is largely based on that used in Lab 1. main() within src/Main.cpp can
be read to show the high-level logic. Fundamentally, a UniformBus instance is created that stores the simulation
parameters such as average frame arrival rate and inter-node distance. UniformBus inherits from the Network class
which defines a general collection of nodes as well as stores statistical counters (some of which are "leaky abstractions"
(https://en.wikipedia.org/wiki/Leaky_abstraction) for the sake of brevity). The instance is passed to the NetworkSimulator
so that it can be accessed when the NetworkSimulator passes itself to the DiscreteEvents that it processes.

The NetworkSimulator class is a subclass of DiscreteEventSimulator<TTime, TState> which provides a generic implementation
for processing DiscreteEvent<TTime, TState> instances. Each DiscreteEvent has its process() method called into which
an instance of TState is passed. In this case, NetworkSimulator sets TTime to the Seconds typedef (an alias for the
"double" type) and TState to itself per the CRTP (https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)
so that instances of the NetworkEvent typedef (DiscreteEvent<TTime, TState> resolved to the same type parameters) can
take in a NetworkSimulator. The subtypes of NetworkEvent will be discussed later.

An instance of the UniformBusSimulatorConfigurer class is created to manage the updating of the NetworkSimulator instance
we pass to it for varying numbers of nodes. This is an implementation of the NetworkSimulatorConfigurer class which the
NetworkAnalyzer uses to reconfigure simulations for the gathering of data for various numbers of nodes. The
UniformBusSimulatorConfigurer class takes in an implementation of NodeFactory to abstract what kinds of nodes it creates.
In this case, we pass in a CSMACDNodeFactory to create subtypes of the Node class that implement the CSMA/CD MAC protocol.
All these classes declared in main() are reused and can have their parameters changed between multiple simulations on the
same session.

After running the executable generated by the build, or clicking "CMake -> Build All" and then the "Main.cpp" run program
button in the top ribbon in Visual Studio, the command list is shown. One simply types the corresponding letter for a
parameter and a valid value after it separated by a space; multiple parameters can be set on the same line.
E.g. The following commands can be used to generate all the plots requested in the default manual (k is 10 by default):

t 1000 ni 20 a 7 r 1000000 l 1500 d 10 p 2e8 m 0
of <absolute path or relative path from working directory>/defaultParameters_m0_a7_trial1
a 10
of <absolute path or relative path from working directory>/defaultParameters_m0_a10_trial1
a 20
of <absolute path or relative path from working directory>/defaultParameters_m0_a20_trial1
a 7 m 1
of <absolute path or relative path from working directory>/defaultParameters_m1_a7_trial1
a 10
of <absolute path or relative path from working directory>/defaultParameters_m1_a10_trial1
a 20
of <absolute path or relative path from working directory>/defaultParameters_m1_a20_trial1

Provided that all parameters were properly entered, main() will run the runAnalysis() method in Main.cpp which calls
validateSettings() and then configures whether to output CSV rows to the console or to a file. The program was designed
for ease of debugging and quickly running new simulations with new values. This eventually calls the NetworkAnalyzer's
gatherDataFor() method for either an individual value or range of values for the number of nodes. The NetworkAnalyzer
class only cares about (is responsible for) running the NetworkSimulatorConfigurer and the simulation that it returns
and then generating CSV rows for that simulation's statistics to be output to any std::ostream.

UniformBusSimulatorConfigurer::configureNetworkSimulationFor(Nodes nodes) resets the simulator state and then configures
multiple Node instances to follow the topology of a "uniform bus" (see UniformBus.hpp for a definition). This function
creates the desired number of nodes and populates them with frames whose inter-arrival times follow an exponential distribution.
Each node then has ChannelConnection instances added to them to define all their network adjacencies, namely all nodes to and
from which signals can be sent and sensed and the distances to them.

Now, the important matter is the simulator design which is largely facilitated by events and the Visitor Pattern
(https://en.wikipedia.org/wiki/Visitor_pattern), or a variation thereof. Here, we have the NodeEvent<TNode> class which is
a subtype of NetworkEvent. A NodeEvent<TNode> defines a NetworkEvent that occurs at a particular node within a network.
In this case, we have the TransmissionAttemptEvent, TransmissionStopEvent, ChannelBusyStartEvent and ChannelBusyEndEvent:
each of these set TNode to a corresponding "_Acceptor" interface (e.g. ChannelBusyStartEventAcceptor). The Node class implements
all four of these interfaces and then uses the Template Method Pattern (https://en.wikipedia.org/wiki/Template_method_pattern)
to allow subtypes such as CSMACDNode to provide specific implementations or add collision detection. Each interface's
"accept_()" method allows an event to pass the NetworkSimulator (TState) instance passed to it and a timestamp to the Node class
which will then update its state and or register a new event accordingly.

At the start, UniformBusSimulatorConfigurer::configureNetworkSimulationFor(Nodes nodes) registers a TransmissionAttemptEvent for
the very first frame of each node. Node::acceptTransmissionAttemptEvent() (see Node.cpp) encapsulates the logic for checking
whether to attempt a transmission. This delegates the implementation of shouldTransmit() to CSMACDNode. CSMACDNode.cpp is another
major place to see the key logic for handling collisions. In CSMACDNode::shouldTransmit(), you can see the fairly basic logic
for how to respond to sensing the channel as being free or busy in the persistent and non-persistent cases, as well as the logic
for updating statistical data.

For the non-persistent case, an exponential backoff is performed if the channel is sensed as busy. The logic for this can be
seen in CSMACDNode::performExponentialBackoff(). ExponentialBackoff::getNextWaitTime() is what advances the collision counter
and determines the next backoff delay. If the maximum invocations or collisions is exceeded, it returns a negative delay and
the current frame is popped without incrementing the number of successfully transmitted frames. Node::popFrame() remove the
current frame from the front of the queue, and if there are any frames left will try to schedule a new TransmissionAttemptEvent
at the maximum of the current time and the arrival time of the next frame (use the later time).

NetworkSimulator::addEvent() checks whether the specified event instance fits within the simulation duration and then inserts
it into a priority queue to automatically order it with respect to the execution times of all other events being generated.

In the persistent case, we must wait for the point in time that a ChannelBusyEndEvent is received that causes the channel to
go idle. What differentiates this approach from the lab's approach for channel busy detection is that it can robustly account
for how the busyness of a channel from the perspective of a particular node while a plethora of signals are propagating through
the channel simultaneously and different sender nodes may have their transmission time truncated upon detecting a collision.

The way this is implemented is that every time Node::attemptTransmission() is called, it calls Node::startTransmission() which
sends a bunch of ChannelBusyStartEvent instances to all adjacent nodes (by enumerating the list of ChannelConnection instances
added by the UniformBusSimulatorConfigurer). These events tell their target nodes _exactly_ when a signal has reached its
terminal. This is facilitated by Node::acceptChannelBusyStartEvent() which _increments_ a numIncomingSignals counter. Then,
when a node _stops_ transmitting, be it via a tentatively scheduled TransmissionStopEvent or a collision detected when
processing a ChannelBusyStartEvent, Node::stopTransmitting() is called which sends a ChannelBusyEndEvent to each adjacent node.
Node::acceptChannelBusyEndEvent() thus _decrements_ the numIncomingSignals counter. Now, if this counter is zero,
Node::channelIsBusy() will return false, else, it will return true. A counter is used instead of a boolean to account for how
multiple signals may be passing through a node's terminal simultaneously.

When a TransmissionAttemptEvent is processed, should the channel sense succeed and it calls Node::attemptTransmission(),
it will _tentatively_ schedule a TransmissionStopEvent at the transmission start time plus the transmission delay for the
current frame. All adjacent nodes will receive a ChannelBusyStartEvent accordingly. An isCurrentlyTransmitting flag is
likewise set to true to help detect collisions. Thus, if a ChannelBusyStartEvent is received while this is true, a collision
is detected and CSMACDNode::acceptChannelBusyStartEventImplementation() aborts the transmission and attempts an
exponential backoff. If the maximum number of backoffs is exceeded, the frame is dropped and a new TransmissionAttemptEvent
is scheduled. When backing off or dropping the frame, the last scheduled TransmissionStopEvent if it hasn't been reached
yet (if it has been reached and processed before the ChannelBusyStartEvent arrived, then isCurrentlyTransmitting would have
been false) will then be cancelled so that when the NetworkEventSimulator reaches it, it simply won't do anything. So the
history and balance of ChannelBusyStartEvent and ChannelBusyEndEvent instances being processed at this node prior to
a TransmissionAttemptEvent or TransmissionStopEvent being received and processed is crucial to accurately determining whether
a node detects the channel as busy or detects a collision.

Finally, in the persistent case, CSMACDNode::acceptChannelBusyStopEventImplementation() augments the default template method
and determines that if the node isn't currently backed off, is in fact waiting (last sensed the channel as being busy), and
in receiving the ChannelBusyStopEvent, numIncomingSignals was decremented to 0 such that the channel has turned idle at this
node's terminal, then it should immediately attempt a transmission without having to schedule a new event (unless a
processing delay is accounted for).

This is how our design more accurately and robustly implements persistent and non-persistent CSMA/CD with all its complicated
dynamics.

**Observations**:

It is strongly recommended that the reader directly consult the .csv and .xlsx files within the ./data folder.

Early on, by setting "ni 1" to simulate only 1 node and "a 10" or "a 100", we could test and observe a total number of frames
being transmittedthat is in line with the expected average number of frame arrivals per second for the exponential distribution.
When later adding the ability to print out the total number of frames enqueued by the UniformBusSimulatorConfigurer,
for example with the case of "a 100" or an expectation of 100 frame arrivals per second, indeed, quite consistently, the
recorded total enqueued frames was very close in value to "nodes * rate * simulation duration". So for "t 1000", "ni 20" and
"a 10", we get Tef (total enqueued frames) equal to around 200,000 as expected.

A simulation duration of 1,000 seconds ("t 1000") was selected which produces _plenty_ of frames to be attempted to be transmitted.
The default data requested by the original lab manual is compiled and graphed within graphs.xlsx. So far, even after trying a
trial with "t 2000", it seems like with the current design, actual overall throughputs and network performance can be highly
sporadic, whereby it is very difficult to find a consistent trend for non-normalized statistics. For sure, no trend could be
observed for the throughputs, else, a complicated script would have to be implemented to find the mean and variance of _many_
trials for the same simulation parameters, which we did not have the time to implement.

The CSV files show the addition of many more statistical counters and ratios, whereby these too do appear to be sporadic but
at least in general appear to show a general decrease with increasing numbers of nodes. Statistics were likewise added to
prove that the exponential backoffs in the persistent and non-persistent cases were in fact working. Some logic was also
implemented to determine the average number of backoff iterations per initiated exponential backoff to see how close nodes
come to dropping frames. With most parameters chosen including "a 100", it appears to be _extremely_ rare for nodes to even
undergo a channel busy or collision twice in a row. Logic was added to allow one to change "k" to a number lower than 10 to
better log statistics on frame drop rates.

Much more work will be needed to analyze this model statistically or determine the parameters required for the achieving of
more consistent throughputs and the maximization of consecutive collisions.

Some hypotheses are that an increased inter-node distance or decreased channel propagation speed can increase the chance of
collisions, likewise the decreasing of the channel transmission rate or increasing the frame length, but these must all be selected
with the total node count so as to avoid _late collisions_
(https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection#Late_collision,
https://www.ionos.ca/digitalguide/server/know-how/csmacd-carrier-sense-multiple-access-collision-detection/)
where a node fully transmits a node before it can detect that a collision with a sufficiently far away node occurred.

Earlier on during testing, with some parameters, it seemed like maximizing the frame arrival rate and or setting the frame length to
a large number actually caused the throughput to saturate to some maximum and show more drastic and consistent decreases in efficiency
(see ./data/test_t1000_nl20_nu100_ns20_m0_a100_l15000_trial1.csv).
For other parameters, it seemed like a larger frame arrival rate actually made collisions _less_ likely, namely because it would
become much more common for a node to sense the channel as busy. As a result, extra statistical metrics were added to determine how
often nodes were actually sensing the channel as busy. Unfortunately, we have been having difficulty proving this hypothesis or finding
parameters in the non-persistent case where a node senses the channel as busy multiple times in a row. It does not appear that there is
a bug within CSMACDNode::shouldTransmit() that would completely prevent this case from properly occuring or being properly counted.
It is nonetheless hypothesized that frame drops will be more common in the non-persistent case, due to the expected increase in sensing
the channel as busy.