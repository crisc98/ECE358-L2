***Contents***:

Relative to the directory in which this file is contained, you may find the following:

 ./data - Contains CSV files generated by the program to generate the graphs to be used in the report.
 ./docs - Would have contained the report and UML diagram.
 ./src - Contains all the C++ source code required to perform the experiments.
 ./CMakeLists.txt - Used by CMake to allow cross-platform building of this C++ project.

***Running the program***:

To build this program on eceubuntu, first, within the same folder as this README file,
call "cmake ."; this initializes the CMake configuration. After this is done,
call "cmake --build ." to build the binary.

To run the program after building with CMake, call "./bin/ECE358-L2".

The program will automatically show a list of commands, their usage and description.
Very rigorous error-checking was implemented.

This program was designed to be able to perform multiple simulations and generate
multiple CSV outputs in a single session, also allowing you to change multiple simulation
parameters in one line.

***The state of this submission***:

When approaching this lab, it was unfortunately determined that there is likely a
potentially major flaw in the default description of the simulation algorithm as
described in the lab manual and slides. As a result, the code likely doesn't build
yet despite being largely fledged out and structured with all of its interfaces,
whereby good and superior data could probably be obtainable if given a few extra hours.

All the code is thoroughly documented with programming comments, whereby given our
time constraints, direct consultation of the code is the best way to ascertain its
structure, design and functionality. The structure of main, and the concept of
"simulators" and "analyzers" is very similar to our Lab 1 submission, so please
consult that lab's report for an idea.

Firstly, from a basic calculation, it was confirmed that "late collisions" shouldn't be
possible in this network given the lab parameters
(see https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection#Late_collision).

The desired exercise was to implement the program in accordance with the SOLID programming principles
in order to generate potentially enterprise quality code (see https://en.wikipedia.org/wiki/SOLID).
It is quite time-consuming to design code to be loosely coupled, but is arguably a valuable practice
for the industry.

The flaw is that the prescribed algorithm may actually _erroneously_ mark the channel at a node's
location as being busy at a certain time; that is, the channel is _not_ always busy for the whole
duration of the original transmitting node's frame transmission. It is possible, especially with a
fast channel propagation speed, after choosing a sending node, for subsequent and sufficiently
temporally and spatially close node to begin transmitting such that the sending node's transmission
time is cut short, _and_ as a result, a third node could have actually started transmitting quite
earlier _without_ a collision or sensing that the channel was busy.

With the prescribed implementation, what happens is that the second node correctly detects a collision,
but the third node erroneously senses the channel as being busy when in reality, it wouldn't have because
the sending node would have stopped transmitting or aborted earlier than its nominal transmission time.

If the sending node and second node's frames are transmitted very close in time and these two nodes
are very close spatially, then the error in the duration of the channel busy time is maximized.

Simply, the prescribed solution isn't sophisticated enough.

Thus, an alternate approach was attempted in which one still has a data structure of nodes with
frame queues that are populated accordingly. To implement the loop for finding the earliest frame
among the nodes, we would have used a priority queue anyways. This priority queue was expanded into
a full fledged generic DiscreteEventSimulator<> implementation and hence a NetworkSimulator class.
The NetworkSimulator class allows for special Network events linked to specific nodes to be registered.

The big idea is that each node stores a counter for determining if the channel is busy at its location.
Each node when transmitting then sends transmission start or stop events to all the other nodes which
will update their busy counters accordingly. This architecture allows for a _much_ more accurate
determination of when a channel is actually busy while additionally facilitating an implementation of the
jamming signal delay.

Please judge whether a slightly late but working submission of this sophisticated implementation
would be acceptable.

***Time Spent***:

~22 hours of pre-deadline work

2020-03-12:

***Main changes***:

- The "CSMACDChannelBusy_Event" classes were changed to be generic and not specific to CSMA/CD.
- The "ChannelSenseEvent" class was renamed to "TransmissionAttemptEvent".
- The proposed "CSMACDTransmissionStopEvent" was changed to a generic "TransmissionStopEvent".
- Implemented the Visitor Pattern where the "Node" class can now accept the above events, or rather
  the state they wish for it to process. The event classes now do not perform any state changes of
  their own, instead delegating it to the specific "Node" class implementation.
- Deprecated and removed the "ChannelSenseEventFactory" and "CSMACDChannelSenseEventFactory" classes.
- Changed network topologies to be defined by the addition of various "ChannelConnection" instances
  to each "Node". Instead of having a dedicated "UniformBus" class, the "UniformBusSimulatorConfigurer"
  will build a bus network accordingly.
- Added a "cancelled" flag to the "DiscreteEvent<>" class to allow events to be ignored instead of
  going through the difficulty of removing them from the priority queue before they have been reached.
- Changed the totalTransmittedBits counter into a double to handle massive values.

***Time Spent***:

~12 hour of post-deadline thought, design and implementation.

2020-03-13:

***Time Spent***:

2.5 hours to fix all compiler and linker errors
6 hours debugging logic errors
1 hour testing and gathering/analyzing data (still in progress)

First test commands:
t 1000 ni 20 a 7 r 1000000 l 1500 d 10 p 2e8 m 0 oc
